#!/usr/bin/env python3
"""
Version synchronization script for Hei-DataHub.

Reads version.yaml and generates version stubs for:
- Python: src/mini_datahub/_version.py
- Docs: docs/_includes/version.md
- Build: build/version.json
- Updates pyproject.toml version field

Usage:
    python scripts/sync_version.py [--dry-run]
"""

import argparse
import json
import re
import sys
from pathlib import Path
from typing import Dict, Any

try:
    import yaml
except ImportError:
    print("Error: pyyaml is required. Install with: pip install pyyaml")
    sys.exit(1)

# Project root
ROOT = Path(__file__).parent.parent.absolute()
VERSION_YAML = ROOT / "version.yaml"


def load_version_config() -> Dict[str, Any]:
    """Load version configuration from version.yaml."""
    if not VERSION_YAML.exists():
        print(f"Error: {VERSION_YAML} not found")
        sys.exit(1)

    with open(VERSION_YAML, 'r') as f:
        config = yaml.safe_load(f)

    required = ['version', 'codename', 'release_date', 'compatibility']
    missing = [k for k in required if k not in config]
    if missing:
        print(f"Error: Missing required fields in version.yaml: {', '.join(missing)}")
        sys.exit(1)

    return config


def generate_python_version(config: Dict[str, Any], dry_run: bool = False) -> str:
    """Generate Python version module."""
    version = config['version']
    # Parse version into components
    parts = version.split('-')
    base_version = parts[0]
    prerelease = parts[1] if len(parts) > 1 else None

    version_parts = base_version.split('.')
    major, minor, patch = map(int, version_parts)

    version_tuple = f"({major}, {minor}, {patch}"
    if prerelease:
        version_tuple += f', "{prerelease}"'
    version_tuple += ")"

    # Calculate build number (MMNNPP format)
    build_number = f"{major:02d}{minor:02d}{patch:02d}"

    content = f'''"""
Auto-generated version information for Hei-DataHub.

DO NOT EDIT THIS FILE DIRECTLY!
This file is generated by scripts/sync_version.py from version.yaml
"""

# Version Components
__version__ = "{version}"
__version_info__ = {version_tuple}

# Application Metadata
__app_name__ = "{config.get('app_name', 'Hei-DataHub')}"
__license__ = "{config.get('license', 'MIT')}"
__description__ = "A local-first TUI for managing datasets with consistent metadata"

# Build Information
BUILD_NUMBER = "{build_number}"
RELEASE_DATE = "{config['release_date']}"
CODENAME = "{config['codename']}"
COMPATIBILITY = "{config['compatibility']}"
RELEASE_NOTES = "{config.get('notes', '')}"

# Repository Information
GITHUB_REPO = "{config.get('github_repo', '0xpix/Hei-DataHub')}"
GITHUB_URL = f"https://github.com/{{GITHUB_REPO}}"
ISSUES_URL = f"{{GITHUB_URL}}/issues"
DOCS_URL = "https://0xpix.github.io/Hei-DataHub"

# Update Check Configuration
UPDATE_CHECK_URL = f"https://api.github.com/repos/{{GITHUB_REPO}}/releases/latest"
UPDATE_CHECK_INTERVAL = 86400  # 24 hours in seconds


def get_version_string(include_build: bool = False) -> str:
    """Get the version string with optional build number."""
    version = __version__
    if include_build:
        version = f"{{version}} (build {{BUILD_NUMBER}})"
    return version


def get_version_info() -> dict:
    """Get comprehensive version information as a dictionary."""
    import sys
    return {{
        "version": __version__,
        "version_tuple": __version_info__,
        "app_name": __app_name__,
        "build_number": BUILD_NUMBER,
        "release_date": RELEASE_DATE,
        "codename": CODENAME,
        "compatibility": COMPATIBILITY,
        "release_notes": RELEASE_NOTES,
        "python_version": f"{{sys.version_info.major}}.{{sys.version_info.minor}}.{{sys.version_info.micro}}",
        "python_implementation": sys.implementation.name,
        "github_repo": GITHUB_REPO,
        "github_url": GITHUB_URL,
        "docs_url": DOCS_URL,
    }}


def print_version_info(verbose: bool = False) -> None:
    """Print version information to stdout."""
    print(f"{{__app_name__}} {{__version__}}")
    if verbose:
        print(f"Build: {{BUILD_NUMBER}}")
        print(f"Release Date: {{RELEASE_DATE}}")
        print(f"Codename: {{CODENAME}}")
        print(f"Compatibility: {{COMPATIBILITY}}")
        print(f"Repository: {{GITHUB_URL}}")
        print(f"Documentation: {{DOCS_URL}}")
        import sys
        print(f"Python: {{sys.version_info.major}}.{{sys.version_info.minor}}.{{sys.version_info.micro}} ({{sys.implementation.name}})")
'''

    output_path = ROOT / "src" / "mini_datahub" / "_version.py"
    if not dry_run:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w') as f:
            f.write(content)

    return str(output_path)


def generate_docs_version(config: Dict[str, Any], dry_run: bool = False) -> str:
    """Generate docs version include file."""
    content = f'''!!! info "Version Notice â€” {config['codename']}"
    **This manual tracks {config['compatibility']}.**

    **Release:** {config['version']} ({config['release_date']})
    **Codename:** {config['codename']}

    {config.get('notes', '')}

    **Compatibility note:** Features and shortcuts may differ slightly from other versions.
'''

    output_path = ROOT / "docs" / "_includes" / "version.md"
    if not dry_run:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w') as f:
            f.write(content)

    return str(output_path)


def generate_build_version(config: Dict[str, Any], dry_run: bool = False) -> str:
    """Generate build/version.json for tooling."""
    data = {
        "version": config['version'],
        "codename": config['codename'],
        "release_date": config['release_date'],
        "compatibility": config['compatibility'],
        "notes": config.get('notes', ''),
        "app_name": config.get('app_name', 'Hei-DataHub'),
        "github_repo": config.get('github_repo', '0xpix/Hei-DataHub'),
        "github_url": f"https://github.com/{config.get('github_repo', '0xpix/Hei-DataHub')}",
        "docs_url": "https://0xpix.github.io/Hei-DataHub",
    }

    output_path = ROOT / "build" / "version.json"
    if not dry_run:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w') as f:
            json.dump(data, f, indent=2)

    return str(output_path)


def update_pyproject_toml(config: Dict[str, Any], dry_run: bool = False) -> tuple[str, int]:
    """Update version in pyproject.toml."""
    pyproject_path = ROOT / "pyproject.toml"

    if not pyproject_path.exists():
        return str(pyproject_path), 0

    with open(pyproject_path, 'r') as f:
        content = f.read()

    # Replace version line
    new_content, count = re.subn(
        r'^version\s*=\s*"[^"]+"',
        f'version = "{config["version"]}"',
        content,
        flags=re.MULTILINE
    )

    if not dry_run and count > 0:
        with open(pyproject_path, 'w') as f:
            f.write(new_content)

    return str(pyproject_path), count


def update_legacy_version_py(config: Dict[str, Any], dry_run: bool = False) -> tuple[str, int]:
    """Update legacy version.py to import from _version."""
    version_py_path = ROOT / "src" / "mini_datahub" / "version.py"

    if not version_py_path.exists():
        return str(version_py_path), 0

    content = f'''"""
Version information for mini-datahub.

This module imports from _version.py which is auto-generated.
For version updates, edit version.yaml and run scripts/sync_version.py
"""

from mini_datahub._version import (
    __version__,
    __version_info__,
    __app_name__,
    __license__,
    __description__,
    BUILD_NUMBER,
    RELEASE_DATE,
    CODENAME,
    COMPATIBILITY,
    RELEASE_NOTES,
    GITHUB_REPO,
    GITHUB_URL,
    ISSUES_URL,
    DOCS_URL,
    UPDATE_CHECK_URL,
    UPDATE_CHECK_INTERVAL,
    get_version_string,
    get_version_info,
    print_version_info,
)

__all__ = [
    "__version__",
    "__version_info__",
    "__app_name__",
    "__license__",
    "__description__",
    "BUILD_NUMBER",
    "RELEASE_DATE",
    "CODENAME",
    "COMPATIBILITY",
    "RELEASE_NOTES",
    "GITHUB_REPO",
    "GITHUB_URL",
    "ISSUES_URL",
    "DOCS_URL",
    "UPDATE_CHECK_URL",
    "UPDATE_CHECK_INTERVAL",
    "get_version_string",
    "get_version_info",
    "print_version_info",
]
'''

    if not dry_run:
        with open(version_py_path, 'w') as f:
            f.write(content)

    return str(version_py_path), 1


def main():
    parser = argparse.ArgumentParser(description="Sync version from version.yaml to all surfaces")
    parser.add_argument('--dry-run', action='store_true', help='Show what would be done without making changes')
    args = parser.parse_args()

    print("=" * 70)
    print("Hei-DataHub Version Sync")
    print("=" * 70)

    # Load config
    print(f"\nðŸ“– Loading version config from: {VERSION_YAML}")
    config = load_version_config()

    print(f"\nâœ¨ Version: {config['version']}")
    print(f"   Codename: {config['codename']}")
    print(f"   Release Date: {config['release_date']}")
    print(f"   Compatibility: {config['compatibility']}")

    if args.dry_run:
        print("\nâš ï¸  DRY RUN MODE - No files will be modified\n")
    else:
        print()

    # Generate files
    files_generated = []

    print("ðŸ“ Generating version stubs...")

    # Python version module
    path = generate_python_version(config, args.dry_run)
    files_generated.append(path)
    print(f"   âœ“ {path}")

    # Docs version include
    path = generate_docs_version(config, args.dry_run)
    files_generated.append(path)
    print(f"   âœ“ {path}")

    # Build version.json
    path = generate_build_version(config, args.dry_run)
    files_generated.append(path)
    print(f"   âœ“ {path}")

    print("\nðŸ“¦ Updating packaging manifests...")

    # Update pyproject.toml
    path, count = update_pyproject_toml(config, args.dry_run)
    if count > 0:
        files_generated.append(path)
        print(f"   âœ“ {path} ({count} replacement)")
    else:
        print(f"   âŠ˜ {path} (no changes needed)")

    # Update legacy version.py
    path, count = update_legacy_version_py(config, args.dry_run)
    if count > 0:
        files_generated.append(path)
        print(f"   âœ“ {path} (updated to import from _version)")

    # Summary
    print("\n" + "=" * 70)
    if args.dry_run:
        print(f"âœ… Dry run complete. Would generate/update {len(files_generated)} files.")
    else:
        print(f"âœ… Sync complete! Generated/updated {len(files_generated)} files.")
    print("=" * 70)

    if not args.dry_run:
        print("\nðŸ“‹ Next steps:")
        print("   1. Verify generated files")
        print("   2. Update docs/99-changelog.md with release notes")
        print("   3. Test: hei-datahub --version")
        print("   4. Commit changes with: git add -A && git commit -m 'chore(version): bump to " + config['version'] + "'")


if __name__ == '__main__':
    main()
